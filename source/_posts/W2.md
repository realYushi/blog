---
title: Dev-log, Week 2, To-Do List App
date: 2024-06-24 23:58:57
tags:
    - project
    - To-Do List
    - Dev-log
---

### Week 2: Backend Development Part 1

-   **API Design and Development:** Using BDD insights, define and start implementing REST API endpoints using .NET.
-   **Database Design and Implementation:** Model the SQL database reflecting the domain model, set up initial migrations.
-   **Initial API Testing:** Write tests for the newly implemented APIs under the TDD approach.
-   **CI/CD Pipeline Enhancement:** Configure the CI/CD pipeline to automate backend tests and database integration.

---

### Day 1: API Design and Understanding Testing Methodologies

Today marked a significant step in my project as I began working on the API design. I chose to use OpenAPI to define the API, which proved to be an intuitive tool, helping to naturally generate the API schema. This process made me realize the importance of designing the database first to have a clearer understanding of the data structure. Therefore, I plan to focus on database design tomorrow.

The clarity provided by OpenAPI made the API easy to understand, and I managed to create module files for both the API and the database. In addition, I discovered the benefits of separating the production and test projects, ensuring that test code does not mix into the production environment. This separation is further managed by manually adjusting the `.csproj` files, which links the various project components together in .NET.

I also delved deeper into the relationship between BDD (Behavior-Driven Development) and unit testing. BDD focuses on the bigger picture—how the product should function—while unit testing hones in on the details of how individual functions operate. This understanding clarified my testing approach: starting with BDD tests to outline the expected behaviors and then moving on to unit tests to ensure each function performs as intended.

Today’s reflections also led to a deeper understanding of TDD (Test-Driven Development). Initially, I mistook TDD for a specific framework, but now I recognize it as a methodology or way of thinking where tests are written before the actual code. This approach ensures that the code not only functions correctly but also meets the expected behaviors defined by the tests.

**What I Learned Today:**

1. Utilizing OpenAPI for clear and effective API definition.
2. Creating and managing module files for APIs and databases.
3. The importance of separating production and test environments in project architecture.
4. The technique of linking project components by manually editing `.csproj` files.
5. The distinct roles and interactions between BDD and unit testing.
6. The true essence of TDD as a proactive coding methodology.

This deeper understanding of testing methodologies and project structuring is proving invaluable as I continue to build a robust and functional application.

---

### Days 2 and 3: Database Design and Implementation

Over the past two days, significant progress has been made on the database side of my To-Do List application. I focused on refining the model files with necessary data annotations, allowing EF Core to better understand the models and generate the database schema accurately. This step is crucial as it ensures that the data structure aligns seamlessly with the application’s needs.

**Improvements and Implementations:**

-   **Docker File Refinement:** I updated the Docker file to use environment variables for the database connection string. This approach enhances security by keeping sensitive information out of the codebase.
-   **Migration and Schema Updates:** I added the initial migration to the project, which automates the creation of the database schema. Additionally, I included code in the `Program.cs` file to check and update the database schema upon application startup, ensuring the database is always aligned with the current model definitions.
-   **Handling Certification Issues:** I encountered a certification issue that initially slowed progress. However, I learned to adjust the connection string to temporarily bypass this problem, allowing me to proceed without interruptions.

Today, I successfully created the database schema within the database, and the application is running smoothly. I was also able to use SQL tools to verify the structure of the database schema, which was a satisfying confirmation of the day’s success.

EF Core proved to be incredibly convenient for managing database schemas. It’s remarkable how it reduces the need for manually writing SQL code, streamlining the development process significantly.

**What I Learned:**

1. The importance of refining model files with data annotations to guide EF Core in schema generation.
2. Securing sensitive data using environment variables within Docker files.
3. Implementing migrations in EF Core to automate database schema creation.
4. Ensuring the application dynamically updates the database schema through code in `Program.cs`.
5. Overcoming connectivity issues by modifying connection strings.
6. Validating database schemas using SQL tools to ensure accuracy.

The progress over these two days has been incredibly encouraging, and I'm pleased with the functionality and stability of the database interactions. Tomorrow, I plan to focus on API testing, continuing to build on the robust foundation established for the application’s backend.

---
