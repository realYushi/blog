---
title: Dev-log, Week 3, To-Do List App
date: 2024-07-01 23:18:49
tags:
    - project
    - To-Do List
    - Dev-log
---

### Week 3: Backend Development Part 2

-   **Complete API Implementation:** Finish all backend functionalities with corresponding unit and integration tests.
-   **WebSocket Implementation:** Integrate WebSockets for real-time functionalities.
-   **CI/CD for Real-Time Services:** Ensure WebSocket implementations are covered by automated tests and deployment strategies.
-   **Backend Dockerization:** Finalize Docker setup for the backend, ensuring smooth deployment through the CI/CD pipeline.

---

### Day 1: Completing Unit Tests for the Backend

Today marked significant progress as I successfully completed the unit testing for the backend of my To-Do List application, setting a strong pace for the week. The journey began with a bit of a hiccup as I spent some time deliberating over which tools to use for testing. I soon realized that the core concepts across different testing tools are quite similar, leading me to the insight that it's best to choose one tool and fully commit to it.

**Tool Selection and Setup:**

-   **NUnit:** I selected NUnit as my primary unit testing framework due to its robust features and widespread acceptance in the .NET community.
-   **Moq:** To handle dependency mocking, I opted for Moq, which proved invaluable in simulating the behavior of complex dependencies.
-   **Fluent Assertions:** I integrated Fluent Assertions to enhance the readability and maintainability of the assertions, finding it more intuitive compared to the standard NUnit assertions.

**Testing Strategy:**
During the development of the tests, I deepened my understanding of the relationships among model files, DTOs, and repository files. Implementing tests using the traditional AAA (Arrange, Act, Assert) pattern helped structure my tests clearly and effectively.

One key change I made in the application was shifting the data type of the ID from integer to string, utilizing UUIDs for setting IDs. This change provides greater flexibility and better alignment with modern application standards.

**What I Learned:**

-   **Tool Consistency:** It's crucial to pick a tool and stick with it to avoid wasting time and effort.
-   **Mocking with Moq:** Leveraging Moq to simulate repository interactions allows for more focused and effective testing.
-   **AAA Pattern:** The Arrange-Act-Assert pattern is a powerful structure for writing clear and concise unit tests.
-   **ID Flexibility:** Using strings for IDs, set by UUID, offers flexibility and simplifies integration across diverse systems.
-   **Bidirectional Testing:** When testing functionalities like task creation, it's important to validate both directions of data mapping with AutoMapper — from DTO to model and vice versa.

Today was a productive start to the week, solidifying the backend's stability and readiness for integration with the frontend. As I move forward, I am equipped with powerful tools and strategies to ensure the quality and reliability of the application.

---

### Day 2: Completing the Service Layer and Exploring Integration Tests

Today was another intensive day of learning and development on my To-Do List application. As I dive deeper into Test-Driven Development (TDD), I’m appreciating how it sharpens my focus and enhances my productivity. TDD's iterative process of writing tests, passing them, and then refactoring ensures that I only concentrate on what's essential at the moment. This approach has been so effective that I plan to extend it to the frontend development to bolster my coding practices there as well.

**Service Layer and Repository Concerns:**
The service layer came together straightforwardly; however, I encountered a conceptual challenge when deciding where to place the database commit function. Initially, I thought it best to leave it within the repository layer, as it directly involves data access. Yet, after further research, I realized that moving it to the service layer—or potentially the controller—would allow for managing multiple transactions more effectively.

This revelation led me down the rabbit hole into the "unit of work" pattern. Although I first felt it was an overdesign—given that EF Core already implements this pattern internally—the prospect of potentially integrating other ORMs like Dapper or managing multiple databases in the future convinced me of its value. Thus, I've decided to incorporate this pattern into my project, seeing it as an excellent opportunity to prepare for more complex scenarios and enhance my architectural knowledge.

**Dependency Injection and Tools:**
The multi-layered architecture, while robust, introduced complexities in manually managing dependencies within `program.cs`. I discovered Autofac, a tool that automates the wiring of dependencies by registering all services and repositories in a container. This simplifies the entire setup, as I only need to register this container in `program.cs`. Another approach I'm considering is utilizing built-in dependency injection with extension methods, which also promises a streamlined way to manage service lifecycles and dependencies.

**What I Learned Today:**

1. **The Efficiency of TDD:** TDD not only helps write better code but also boosts productivity by focusing development efforts on passing tests and achieving green states before refactoring.
2. **Service Layer Responsibilities:** The placement of the commit save function in the service layer can enhance transaction management across services.
3. **Unit of Work Pattern:** Adopting this pattern can future-proof the application against changes in ORM technologies or database management strategies.
4. **Autofac for Dependency Management:** Autofac is an invaluable tool for automating dependency injections, reducing manual setup, and ensuring cleaner code.
5. **Using Extension Methods:** They offer a practical way to organize and register services and repositories in the DI container.

As I continue with the integration testing tomorrow, I'm excited to apply these new structures and tools to see how they contribute to a more robust and maintainable application architecture.

---
